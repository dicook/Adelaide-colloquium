---
title: "Shadows of Data"
subtitle: "Visualising the Geometry of High Dimensions"
title-slide-attributes: 
  data-background-image: "https://dicook.github.io/mulgar_book/images/shadow_puppets.png"
  data-background-size: 50%
  data-background-position: 50% 0%
author: "Dianne Cook <br> Econometrics and Business Statistics <br> Monash University"
format:
  revealjs: 
    theme: [default, custom.scss]
    slide-number: c/t
    slide-tone: false
    width: 1280
    height: 800
    margin: 0.05
    chalkboard: true
    background-transition: fade
code-line-numbers: false
message: false
highlight-style: pygments
html-math-method: mathml
footer: "Tarntanya Aug 2025 [https://dicook.github.io/Adelaide-colloquium/slides.html](https://dicook.github.io/Adelaide-colloquium/slides.html)"
---

```{r, include = FALSE}
library(tidyverse)
library(colorspace)
library(patchwork)
library(tourr)
library(detourr)
library(mulgar)
library(ggfortify)
library(Rtsne)
library(mclust)
library(cxhull)
library(liminal)
library(mvtnorm)
library(quollr)
library(GGally)
library(MASS)
library(classifly)

library(conflicted)
conflict_prefer("filter", "dplyr")
conflict_prefer("select", "dplyr")

options(width = 200)
knitr::opts_chunk$set(
  fig.width = 4,
  fig.height = 4,
  out.width = "80%",
  fig.align = "center",
  dev.args = list(bg = 'transparent'),
  fig.retina = 3,
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  cache = FALSE
)
theme_set(ggthemes::theme_gdocs(base_size = 12) +
  theme(plot.background = 
        element_rect(fill = 'transparent', colour = NA),
        axis.line.x = element_line(color = "black", 
                                   linetype = "solid"),
        axis.line.y = element_line(color = "black", 
                                   linetype = "solid"),
        plot.title.position = "plot",
        plot.title = element_text(size = 18),
        panel.background  = 
          element_rect(fill = 'transparent', colour = "black"),
        legend.background = 
          element_rect(fill = 'transparent', colour = NA),
        legend.key        = 
          element_rect(fill = 'transparent', colour = NA)
  ) 
)
```

## You can't see beyond 3D! {.center}

## ~~You can't see beyond 3D!~~ {.center visibility="uncounted"}

We are going to see that we can gain intuition for structure in high dimensions through visualisation

## The greatest value of a data plot is when it forces us to notice what we never expected to see. <span style="font-size:30%;font-style:italic;">~Adapted from a Tukey quote. </span> {.center}

::: {.fragment .f70}
It doesn't mean that it's easy. It doesn't mean that visualisation is used alone. It means that (high-dimensional) visualisation is an important part of your toolbox, especially to allow discovery of what *we don't know*. 
:::

## Outline

:::: {.columns}
::: {.column width=45%}

- Intuitive explanation of a tour (and 18th century novel)
- Construction of a tour 
- Connection to manifolds (and work at U.Adelaide)
- Why?
- Algorithms in the [tourr](http://ggobi.github.io/tourr/) package
- New developments in recent years
- Showing the **model in the data space**
:::
::: {.column width=5%}

:::
::: {.column width=45%}
- Examples 
    - dimension reduction
    - understanding clustering
    - comparing classification boundaries
    - departures from multivariate normal
    - de-constructing neural network fits
    - ternary diagrams beyond 2D
:::
::::

## High-dimensional visualisation using shadows

:::: {.columns}

::: {.column width="50%"}

<center>
![](images/shadow-puppets2.png){fig-alt="Shadow puppet photo where shadow looks like a bird flying."}
</center>

:::

::: {.column width="50%"}

<br><br><br>
Tours of high-dimensional data are like examining the shadows (projections) 
<br><br><br>

::: {.fragment}
(and slices/sections to see through a shadow)
:::

:::
::::

## What "high dimensions" means in statistics

<center>
<img src="images/fig-dimension-cubes-1.png" width="90%">
</center>

Increasing dimension adds an additional orthogonal axis. 

::: {.fragment .f60}
If you want more high-dimensional shapes there is an R package, [geozoo](http://schloerke.com/geozoo/all/), which will generate cubes, spheres, simplices, mobius strips, torii, boy surface, klein bottles, cones, various polytopes, ... 

And read or watch [Flatland: A Romance of Many Dimensions (1884) Edwin Abbott](https://en.wikipedia.org/wiki/Flatland). 
:::

## Notation

::: {.panel-tabset}

## Data

\begin{eqnarray*}
X_{~n\times p} =
[X_{~1}~X_{~2}~\dots~X_{~p}]_{~n\times p} = \left[ \begin{array}{cccc}
x_{~11} & x_{~12} & \dots & x_{~1p} \\
x_{~21} & x_{~22} & \dots & x_{~2p}\\
\vdots & \vdots &  & \vdots \\
x_{~n1} & x_{~n2} & \dots & x_{~np} \end{array} \right]_{~n\times p}
\end{eqnarray*}


## Projection basis

\begin{eqnarray*}
A_{~p\times d} = \left[ \begin{array}{cccc}
a_{~11} & a_{~12} & \dots & a_{~1d} \\
a_{~21} & a_{~22} & \dots & a_{~2d}\\
\vdots & \vdots &  & \vdots \\
a_{~p1} & a_{~p2} & \dots & a_{~pd} \end{array} \right]_{~p\times d}
\end{eqnarray*}


## Projected data

\begin{eqnarray*}
Y_{~n\times d} = XA = \left[ \begin{array}{cccc}
y_{~11} & y_{~12} & \dots & y_{~1d} \\
y_{~21} & y_{~22} & \dots & y_{~2d}\\
\vdots & \vdots &  & \vdots \\
y_{~n1} & y_{~n2} & \dots & y_{~nd} \end{array} \right]_{~n\times d}
\end{eqnarray*}

:::

## 1D projections to see 2D

::: {.panel-tabset}

## 1D projections

:::: {.columns}

::: {.column width="60%" style="font-size: 50%;" .center}


![](gifs/explain_1d.gif){width=500 fig-alt="1D tour of 2D data. Data has two clusters, we see bimodal density in some 1D projections."}

<center>
Data is 2D: $~~p=2$

Projection is 1D: $~~d=1$
</center>

\begin{eqnarray*}
A_{~2\times 1} = \left[ \begin{array}{c}
a_{~11} \\
a_{~21}\\
\end{array} \right]_{~2\times 1}
\end{eqnarray*}

:::

::: {.column width="30%" style="font-size: 70%;"}


::: {.fragment} 

<br>
Notice that the values of $A$ change between (-1, 1). All possible values being shown during the tour.

![](images/explain_1d_axes_1_0.jpg){width="30%"}
![](images/explain_1d_axes_7_7.jpg){width="30%"}
![](images/explain_1d_axes_-7_7.jpg){width="30%"}

<span style="font-size: 50%;">
\begin{eqnarray*}
A = \left[ \begin{array}{c}
1 \\
0\\
\end{array} \right]
~~~~~~~~~~~~~~~~
A = \left[ \begin{array}{c}
0.7 \\
0.7\\
\end{array} \right]
~~~~~~~~~~~~~~~~
A = \left[ \begin{array}{c}
0.7 \\
-0.7\\
\end{array} \right]

\end{eqnarray*}

:::

::: {.fragment} 
<br>
watching the 1D shadows we can see:

- unimodality 
- bimodality, there are two clusters.


<span style="color:#EC5C00"> What does the 2D data look like? Can you sketch it? </span>

:::
:::

::::

## The full 2D

:::: {.columns}

::: {.column width="60%"}

```{r}
#| echo: false
#| fig-width: 3
#| fig-height: 3
#| out-width: 60%
#| fig-alt: "Scatterplot showing the 2D data having two clusters."
data("simple_clusters")

ggplot(simple_clusters, aes(x=x1, y=x2)) +
  geom_point(size=2, alpha=0.8, colour="#EC5C00") +
  theme_minimal() +
  theme(aspect.ratio=1)
```

:::

::: {.column width="30%"}


![](images/explain_1d_annotated.png){fig-alt="2D two cluster data with lines marking particular 1D projections, with small plots showing the corresponding 1D density."}

:::

::::

:::

<!--

## High-dimensional visualisation

:::: {.columns}

::: {.column width="60%" style="font-size: 50%;" .center}

```{r}
#| echo: false
#| eval: false
library(tourr)
library(geozoo)
set.seed(1351)
d <- torus(3, n=4304)$points
d <- apply(d, 2, function(x) (x-mean(x))/sd(x))
colnames(d) <- paste0("x", 1:3)
d <- data.frame(d)
animate_xy(d, axes="bottomleft")
animate_slice(d, axes="bottomleft")
set.seed(606)
path_t2 <- save_history(d, little_tour(), 4)
render_gif(d, 
           planned_tour(path_t2),
           display_xy(col="#EC5C00",
             half_range=3,
             axes="bottomleft"),
           gif_file = "gifs/torus.gif",
           apf = 1/75,
           frames = 1000,
           width = 400, 
           height = 300)
render_gif(d, 
           planned_tour(path_t2),
           display_slice(col="#EC5C00",
             half_range=3,
             axes="bottomleft"),
           gif_file = "gifs/torus_slice.gif",
           apf = 1/75,
           frames = 1000,
           width = 400, 
           height = 300)
```

![](gifs/explain_2d.gif){width=500 fig-alt="Grand tour showing points on the surface of a 3D torus."}

Data is 3D: $p=3$

Projection is 2D: $d=2$

\begin{eqnarray*}
A_{~3\times 2} = \left[ \begin{array}{cc}
a_{~11} & a_{~12} \\
a_{~21} & a_{~22}\\
a_{~31} & a_{~32}\\
\end{array} \right]_{~3\times 2}
\end{eqnarray*}

:::

::: {.column width="30%" style="font-size: 70%;"}


::: {.fragment} 

<br><br><br><br><br><br>
Notice that the values of $A$ change between (-1, 1). All possible values being shown during the tour.

:::

::: {.fragment} 

See: 

- circular shapes
- some transparency, reveals middle
- hole in in some projections 
- no clustering

:::

:::

::::
-->

## 2D projections to see 4D

::: {.panel-tabset}

## Clusters

```{r}
# use only vars of interest, remove two missings, 
# and standardise them for 
# easier interpretation
penguins_sub <- penguins |>
  select(bill_len,
         bill_dep,
         flipper_len,
         body_mass,
         species, 
         sex) |>
  na.omit() |>
  mutate(across(where(is.numeric),  ~ scale(.)[,1])) |>
  rename(bl = bill_len,
         bd = bill_dep,
         fl = flipper_len,
         bm = body_mass)
```

```{r}
#| eval: false
set.seed(645)
render_gif(penguins_sub[,1:4],
           grand_tour(),
           display_xy(col="#EC5C00",
             half_range=3.8, 
             axes="bottomleft", cex=2.5),
           gif_file = "gifs/penguins1.gif",
           apf = 1/50,
           frames = 1600,
           width = 500, 
           height = 400)
```

:::: {.columns}

::: {.column width="50%" style="font-size: 40%;" .center}


![](gifs/penguins1.gif){width=500 fig-alt="Grand tour showing the 4D penguins data. Two clusters are easily seen, and a third is plausible."}


:::

::: {.column width="50%" style="font-size: 70%;"}

::: {.f70}
Data is 4D: $p=4$

Projection is 2D: $d=2$

\begin{eqnarray*}
A_{~4\times 2} = \left[ \begin{array}{cc}
a_{~11} & a_{~12} \\
a_{~21} & a_{~22}\\
a_{~31} & a_{~32}\\
a_{~41} & a_{~42}\\
\end{array} \right]_{~4\times 2}
\end{eqnarray*}

:::


How many clusters do you see?

::: {.fragment} 

- three, right?
- one separated, and two very close,
- and they each have an elliptical shape.

:::
::: {.fragment}
- do you also see an outlier or two?

:::

:::

::::

## Labelled

:::: {.columns}

::: {.column width="60%"}

```{r}
#| eval: false
set.seed(645)
render_gif(penguins_sub[,1:4],
           grand_tour(),
           display_xy(col=penguins_sub$species,
             half_range=3.8, 
             axes="bottomleft", cex=2.5),
           gif_file = "gifs/penguins2.gif",
           apf = 1/50,
           frames = 1600,
           width = 500, 
           height = 400)
```

![](gifs/penguins2.gif){width=500 fig-alt="Grand tour showing the 4D penguins data. Points are coloured by species, which reveals three clusters."}


:::
::: {.column width="40%"}

Species explains the three clusters.

:::

::::

## Only 2D

:::: {.columns}
::: {.column width=60%}

```{r}
#| fig-width: 7
#| fig-height: 6
#| out-width: 80%
ggscatmat(penguins_sub, columns=1:4, col="species") +
  scale_color_discrete_divergingx(palette="Zissou 1") +
  theme(panel.grid.major = element_blank(),
        axis.text = element_blank())
```
:::
::::

## Misses

:::: {.columns}
::: {.column width=25%}

![Best view](images/penguins6.png){width=100% fig-alt="Four projections showing best separation and some anomalies."}
:::
::: {.column width=25%}

![Weird Gentoo](images/penguins3.png){width=400px fig-alt="Four projections showing best separation and some anomalies."}
:::
::: {.column width=25%}


![Weird Chinstrap](images/penguins5.png){width=400px fig-alt="Four projections showing best separation and some anomalies."}

:::
::: {.column width=25%}

![More anomalies](images/penguins4.png){width=400px fig-alt="Four projections showing best separation and some anomalies."}
:::
::::

:::

## Algorithms in the [tourr](http://ggobi.github.io/tourr/) package 

![](images/logo_tourr.png){.absolute bottom=0 right=0 width="200"}

Tours have **two main components**: How to move over the space, and how to display the projected data.

:::: {.columns}
::: {.column .f70 width="50%"}

### Movement

- <span style="color: #EC5C00;"> *choice of target planes* </span>
    - **grand**: random
    - **guided**: objective function
    - **local**: nearby
    - **little**: marginals
    - **manual/radial**: specific variable
- <span style="color: #EC5C00;"> *interpolation between them*</span>
    - **geodesic**: plane to plane (Grassmann manifold)
    - **Givens**: frame/basis to frame/basis (Stiefel manifold)
:::

::: {.column .f80 width="50%"}

### Display

<span style="color: #EC5C00;"> *How should you plot your projected data?*</span>

- **1D**: density, dotplot, histogram
- **2D**: scatterplot, density2D, **sage**, **pca**, **slice**
- **3D**: stereo
- **kD**: parallel coordinates, scatterplot matrix
- **1D+spatial**: image
:::

::::

::: {.fragment .f60}
The packages [detourr](https://casperhart.github.io/detourr/),  [liminal](https://sa-lee.github.io/liminal/) and [lionfish](https://mmedl.github.io/lionfish) take the path produced by [tourr](http://ggobi.github.io/tourr/) functions.
:::

## Connection to work at U. Adelaide

James, A. T. and Constantine, A. G. (1974) Generalized Jacobi Polynomials as Spherical Functions of the Grassmann Manifold, [https://doi.org/10.1112/plms/s3-29.1.174](https://doi.org/10.1112/plms/s3-29.1.174) 

- theoretical foundation for understanding the distribution theory underlying multivariate statistics for hypothesis testing
- was useful for developing the projection pursuit guided algorithm built on indexes derived from Hermite polynomials
- the tour can be used to understand how these test statistics relate to the data: Hotellings $T^2$, Wilks $\Lambda$, Hotelling-Lawley trace, Roy's largest root


## Early tour algorithms 

```{r}
#| eval: false
library(ferrn)
library(purrr)

# 1D in 3D paths
set.seed(1101)
gt1 <- save_history(penguins_sub[,1:3], 
                    tour_path = grand_tour(1), 
                    max_bases=100)
pp1 <- save_history(penguins_sub[,1:3], 
  tour_path = guided_tour(holes(), d=1))
gt1i <- interpolate(gt1)
pp1i <- interpolate(pp1)

#s1 <- sphere.hollow(3, 5000)$points
s1 <- purrr::map(1:5000, ~basis_random(n = 3,  d=1)) %>%
  purrr::flatten_dbl() %>% matrix(ncol = 3, byrow = TRUE) 
gt1_m <- apply(gt1i, 1, c)
pp1_m <- apply(pp1i, 1, c)
s1 <- bind_cols(s1, rep("sphere", 5000))
gt1_m <- bind_cols(gt1_m, rep("grand", nrow(gt1_m)))
pp1_m <- bind_cols(pp1_m, rep("guided", nrow(pp1_m)))
p1 <- rbind(s1, gt1_m, pp1_m)
colnames(p1) <- c(paste0("V", 1:3), "type")
p1$type <- factor(p1$type, levels=c("grand", "sphere", "guided"))
animate_xy(p1[,1:3], col=p1$type, palette="Teal-Rose", 
           cex=c(rep(0.5, 5000), rep(1, nrow(p1)-5000)),
                 axes="off")
render_gif(p1[,1:3],           
           grand_tour(),
           display_xy(col=p1$type, palette="Teal-Rose", 
           cex=c(rep(0.5, 5000), rep(1, nrow(p1)-5000)),
                 axes="off"),
           gif_file = "gifs/tour_paths1d.gif",
           frames = 250,
           width = 300, 
           height = 300)

# 2D in 3D paths
set.seed(1209)
gt2 <- save_history(penguins_sub[,1:3], 
                    tour_path = grand_tour(), 
                    max_bases=200)
pp2 <- save_history(penguins_sub[,1:3], 
  tour_path = guided_tour(holes()))
gt2i <- interpolate(gt2)
pp2i <- interpolate(pp2)

s2 <- purrr::map(1:5000, ~basis_random(n=3,  d=2)) %>%
  purrr::flatten_dbl() %>% matrix(ncol = 6, byrow = TRUE) 
gt2_m1 <- apply(gt2i[,1,], 1, c)
gt2_m2 <- apply(gt2i[,2,], 1, c)
gt2_m <- bind_cols(gt2_m1, gt2_m2)
pp2_m1 <- apply(pp2i[,1,], 1, c)
pp2_m2 <- apply(pp2i[,2,], 1, c)
pp2_m <- bind_cols(pp2_m1, pp2_m2)
s2 <- bind_cols(s2, rep("torus", 5000))
gt2_m <- bind_cols(gt2_m, rep("grand", nrow(gt2_m)))
pp2_m <- bind_cols(pp2_m, rep("guided", nrow(pp2_m)))
p2 <- rbind(s2, gt2_m, pp2_m)
colnames(p2) <- c(paste0("V", 1:6), "type")
p2$type <- factor(p2$type, levels=c("grand", "torus", "guided"))
animate_xy(p2[,1:6], col=p2$type, palette="Teal-Rose", 
           cex=c(rep(0.5, 5000), rep(1, nrow(p2)-5000)),
                 axes="off")
render_gif(p2[,1:6],           
           grand_tour(),
           display_xy(col=p2$type, palette="Teal-Rose", 
           cex=c(rep(0.5, 5000), rep(1, nrow(p2)-5000)),
                 axes="off"),
           gif_file = "gifs/tour_paths2d.gif",
           frames = 300,
           width = 300, 
           height = 300)

# 1D in 4D paths
set.seed(1101)
gt1 <- save_history(penguins_sub[,1:4], 
                    tour_path = grand_tour(1), 
                    max_bases=100)
pp1 <- save_history(penguins_sub[,1:4], 
  tour_path = guided_tour(holes(), d=1))
gt1i <- interpolate(gt1)
pp1i <- interpolate(pp1)

#s1 <- sphere.hollow(3, 5000)$points
s1 <- purrr::map(1:5000, ~basis_random(n = 4,  d=1)) %>%
  purrr::flatten_dbl() %>% matrix(ncol = 4, byrow = TRUE) 
gt1_m <- apply(gt1i, 1, c)
pp1_m <- apply(pp1i, 1, c)
s1 <- bind_cols(s1, rep("sphere", 5000))
gt1_m <- bind_cols(gt1_m, rep("grand", nrow(gt1_m)))
pp1_m <- bind_cols(pp1_m, rep("guided", nrow(pp1_m)))
p1 <- rbind(s1, gt1_m, pp1_m)
colnames(p1) <- c(paste0("V", 1:4), "type")
p1$type <- factor(p1$type, levels=c("grand", "sphere", "guided"))
animate_xy(p1[,1:4], col=p1$type, palette="Teal-Rose", 
           cex=c(rep(0.5, 5000), rep(1, nrow(p1)-5000)),
                 axes="off")
render_gif(p1[,1:4],           
           grand_tour(),
           display_xy(col=p1$type, palette="Teal-Rose", 
           cex=c(rep(0.5, 5000), rep(1, nrow(p1)-5000)),
                 axes="off"),
           gif_file = "gifs/tour_paths1d4d.gif",
           frames = 250,
           width = 300, 
           height = 300)

# 2D in 3D paths
set.seed(1209)
gt2 <- save_history(penguins_sub[,1:4], 
                    tour_path = grand_tour(), 
                    max_bases=200)
pp2 <- save_history(penguins_sub[,1:4], 
  tour_path = guided_tour(holes()))
gt2i <- interpolate(gt2)
pp2i <- interpolate(pp2)

s2 <- purrr::map(1:5000, ~basis_random(n=4,  d=2)) %>%
  purrr::flatten_dbl() %>% matrix(ncol = 8, byrow = TRUE) 
gt2_m1 <- apply(gt2i[,1,], 1, c)
gt2_m2 <- apply(gt2i[,2,], 1, c)
gt2_m <- bind_cols(gt2_m1, gt2_m2)
pp2_m1 <- apply(pp2i[,1,], 1, c)
pp2_m2 <- apply(pp2i[,2,], 1, c)
pp2_m <- bind_cols(pp2_m1, pp2_m2)
s2 <- bind_cols(s2, rep("torus", 5000))
gt2_m <- bind_cols(gt2_m, rep("grand", nrow(gt2_m)))
pp2_m <- bind_cols(pp2_m, rep("guided", nrow(pp2_m)))
p2 <- rbind(s2, gt2_m, pp2_m)
colnames(p2) <- c(paste0("V", 1:8), "type")
p2$type <- factor(p2$type, levels=c("grand", "torus", "guided"))
animate_xy(p2[,1:8], col=p2$type, palette="Teal-Rose", 
           cex=c(rep(0.5, 5000), rep(1, nrow(p2)-5000)),
                 axes="off")
render_gif(p2[,1:8],           
           grand_tour(),
           display_xy(col=p2$type, palette="Teal-Rose", 
           cex=c(rep(0.5, 5000), rep(1, nrow(p2)-5000)),
                 axes="off"),
           gif_file = "gifs/tour_paths2d4d.gif",
           frames = 250,
           width = 300, 
           height = 300)
```

::: {.panel-tabset}

## 3D

:::: {.columns}
::: {.column width=50%}

![](gifs/tour_paths1d.gif){width=400px fig-align="center"}

<center>1D paths on 3D space</center>

:::
::: {.column width=50%}
![](gifs/tour_paths2d.gif){width=400 fig-align="center"}

<center> 2D paths on 3D space </center>

:::
::::

## 4D

:::: {.columns}
::: {.column width=50%}

![](gifs/tour_paths1d4d.gif){width=400px fig-align="center"}

<center>1D paths on 4D space</center>

:::
::: {.column width=50%}
![](gifs/tour_paths2d4d.gif){width=400 fig-align="center"}

<center> 2D paths on 4D space </center>
:::
::::


## Two movement types

:::: {.columns}
::: {.column width=50%}

![](images/elephant-grand.png){width=400 fig-align="center"}

<span style="color:#61A542"> Grand tour</span>: see from all sides
:::
::: {.column width=50%}
![](images/elephant-guided.png){width=400 fig-align="center"}

<span style="color:#CF597E"> Guided tour</span>: Steer towards the most interesting features.
:::
::::

:::

## Recent developments

- **interactivity**: [detourr](https://casperhart.github.io/detourr/), [liminal](https://sa-lee.github.io/liminal/), [langevitour](https://logarithmic.net/langevitour/index.html), [lionfish](https://mmedl.github.io/lionfish)
- **slice/section**: explore shape of models
- **manual/radial tour**: explore sensitivity of structure to particular variables
- **sage**: correct for piling
- **Givens interpolation**: frame to frame. Generally want *geodesic* interpolation because it *removes the distracting within plane spin* but sometimes it is important to move to exact projection.
- **anomaly tour**: compare your sample to a multivariate normal


## Slice

Utilise distance from the projection plane to make the slice, and shift centre of projection plane.


:::: {.columns}
::: {.column width="50%"}

<img src="images/centered-slice.png" width="100%">

:::
::: {.column width="50%"}

<img src="images/orthogonal-distance.png" width="100%">

:::
::::

## Slice tour 

::: {.panel-tabset}

## Torus 3D

:::: {.columns}

::: {.column .f70 width=50%}

Projection

```{r}
#| eval: false
set.seed(839)
torus3D <- geozoo::torus(p=3, n=4000)$points |>
  as_tibble()
t3d <- save_history(torus3D)
animate_xy(torus3D, planned_tour(t3d), axes="off", col="#EC5C00")
render_gif(torus3D, 
           planned_tour(t3d), 
           display_xy(axes="off", col="#EC5C00"), 
           gif_file = "gifs/torus.gif",
           frames=100)
```

![](gifs/torus.gif){width=500 fig-alt="Grand tour showing points on the surface of a 3D torus."}
:::

::: {.column .f70 width=50%}

Slice

```{r}
#| eval: false
animate_slice(torus3D, axes="off", col="#EC5C00")
render_gif(torus3D, 
           planned_tour(t3d), 
           display_slice(axes="off", col="#EC5C00"), 
           gif_file = "gifs/torus_slice.gif",
           frames=100)
```

![](gifs/torus_slice.gif){width=500 fig-alt="Slicetour showing points on the surface of a 3D torus."}
:::
::::

## Torus 4D

:::: {.columns}

::: {.column .f70 width=50%}

Projection

```{r}
#| eval: false
set.seed(839)
torus4D <- geozoo::torus(p=4, n=4000)$points |>
  as_tibble()
t4d <- save_history(torus4D)
animate_xy(torus4D, axes="off", col="#EC5C00")
render_gif(torus4D, 
           planned_tour(t4d), 
           display_xy(axes="off", col="#EC5C00"), 
           gif_file = "gifs/torus4D.gif",
           frames=100)
```

![](gifs/torus4D.gif){width=500 fig-alt="Grand tour showing points on the surface of a 4D torus."}
:::

::: {.column .f70 width=50%}

Slice

```{r}
#| eval: false
animate_slice(torus4D, axes="off", col="#EC5C00")
render_gif(torus4D, 
           planned_tour(t4d), 
           display_slice(axes="off", col="#EC5C00"), 
           gif_file = "gifs/torus4D_slice.gif",
           frames=100)
```

![](gifs/torus4D_slice.gif){width=500 fig-alt="Slicetour showing points on the surface of a 4D torus."}
:::
::::

## Hollow?

:::: {.columns}

::: {.column .f70 width=50%}

```{r}
#| eval: false
set.seed(851)
cube9d <- geozoo::cube.face(p=9)$points |>
  as_tibble()
cube9d <- cube9d[-c(1:512), ]
cube9d <- cube9d - 0.5
animate_xy(cube9d, axes="off", col="#EC5C00")
render_gif(cube9d, 
           grand_tour(), 
           display_xy(axes="off", col="#EC5C00"), 
           gif_file = "gifs/cube9d.gif",
           frames=100)
animate_slice(cube9d, axes="off", col="#EC5C00")

set.seed(851)
sphere4D <- geozoo::sphere.solid.random(p=4, n=4000)$points |>
  as_tibble()
spherehollow4D <- geozoo::sphere.hollow(p=4, n=4000)$points |>
  as_tibble()
animate_xy(sphere4D, axes="off", col="#EC5C00")
render_gif(sphere4D, 
           grand_tour(), 
           display_xy(axes="off", col="#EC5C00"), 
           gif_file = "gifs/sphere4D.gif",
           frames=100)
animate_slice(sphere4D, axes="off", col="#EC5C00")
render_gif(sphere4D, 
           grand_tour(), 
           display_slice(axes="off", col="#EC5C00"), 
           gif_file = "gifs/sphere4D_slice.gif",
           frames=100)

render_gif(spherehollow4D, 
           grand_tour(), 
           display_xy(axes="off", col="#EC5C00"), 
           gif_file = "gifs/spherehollow4D.gif",
           frames=100)

render_gif(spherehollow4D, 
           grand_tour(), 
           display_slice(axes="off", col="#EC5C00"), 
           gif_file = "gifs/spherehollow4D_slice.gif",
           frames=100)
```

![](gifs/sphere4D.gif){width=500 fig-alt="Grand tour showing points in a 4D sphere."}
:::

::: {.column .f70 width=50%}


![](gifs/spherehollow4D.gif){width=500 fig-alt="Tour showing points on the surface of a 4D sphere."}
:::
::::

## or solid?

:::: {.columns}

::: {.column .f70 width=50%}


![](gifs/sphere4D_slice.gif){width=500 fig-alt="Slice tour showing points in a 4D sphere."}
:::

::: {.column .f70 width=50%}


![](gifs/spherehollow4D_slice.gif){width=500 fig-alt="Slice tour showing points on the surface of a 4D sphere."}
:::
::::

:::

## Sage transformation [(1/2)]{.f50}

<center>
<img src="images/sage-density-1.png" width="100%">
</center>

::: {.f70}

As number of variables increase concentration in centre of projection increases. Great for studying distribution of means (Central Limit Theorem) but bad for visualising high-dimensional data. Possibly obscures interesting structure. 
:::

## Sage transformation [(2/2)]{.f50}

```{r eval=FALSE, echo=FALSE}
sphere10 <- geozoo::sphere.solid.random(10)$points
colnames(sphere10) <- paste0("x", 1:10)
render_gif(sphere10, grand_tour(), display_xy(axes="bottomleft"), gif_file = "sphere.gif")
render_gif(sphere10, grand_tour(), display_sage(axes="bottomleft"), gif_file = "sphere_sage.gif")

```

:::: {.columns}
::: {.column width="50%"}

<center>
<img src="gifs/sphere.gif" width="80%">

2D projections of 10D sphere
</center>
:::

::: {.column width="50%"}
::: {.fragment}
<center>
<img src="gifs/sphere_sage.gif" width="80%">

Sage transformation on projected data
</center>
:::
:::
::::

## Givens interpolation [(1/2)]{.f50}

![](images/logo_woylier.png){.absolute bottom=0 right=0 width="150"}

:::: {.columns}
::: {.column style="font-size: 70%; width: 20%;"}

![](images/dog.png)

TARGET BASIS (would show dog if we could find)

:::
::: {.column width=80%}

::: {.fragment}

![](images/dog_index.png){.absolute width=80% top=150}

<center> Grassmann<span style="color:white">------------------------------</span>Stiefel </center>


:::
:::
::::

## Givens interpolation [(2/2)]{.f50}

:::: {.columns}
::: {.column width="70%"}

![](images/spline_index.png){fig-layout="left"}
:::

::: {.column width="30%"}
::: {.fragment .f70}

<center> <span style="color:white">--------</span>Givens<span style="color:white">-----</span>geodesic </center>

![](images/compare-paths.png){width=400 fig-layout="left"}

:::
:::

::::

::: {.fragment .f70}
Givens interpolation ends at requested frame, but geodesic interpolation arrives at the plane, is frame-agnostic, and that is problematic for optimisation using the guided tour.
:::

## Interactivity: exploration

If you want to discover and mark the clusters you see, you can use the [detourr](https://casperhart.github.io/detourr/) package to spin and brush points. Here's a live demo. Hopefully this works.

<br>

```{r}
#| echo: true
#| eval: false
library(detourr)
set.seed(645)
detour(penguins_sub[,1:4], 
       tour_aes(projection = bl:bm)) |>
       tour_path(grand_tour(2), fps = 60, 
                 max_bases=40) |>
       show_scatter(alpha = 0.7, 
                    axes = FALSE, 
                    size = 2)
```

<br><center> DEMO </center>


## Manual/radial tour

```{r}
#| eval: false
#| echo: false
set.seed(941)
proj <- animate_xy(penguins_sub[,1:4],
                    guided_tour(
                      lda_pp(penguins_sub$species)),
           axes = "bottomleft", col=penguins_sub$species)
best_proj <- proj$basis[[length(proj$basis)]]
render_gif(penguins_sub[,1:4], 
           radial_tour(best_proj, mvar=3), 
           display_xy(half_range=4.2,
                      col=penguins_sub$species),
           gif_file="gifs/p_radial_fl.gif",
           apf = 1/60,
           frames=500,
           width=400,
           height=400,
           loop=FALSE)
render_gif(penguins_sub[,1:4], 
           radial_tour(best_proj, mvar=1), 
           display_xy(half_range=4.2,
                      col=penguins_sub$species),
           gif_file="gifs/p_radial_bl.gif",
           apf = 1/60,
           frames=500,
           width=400,
           height=400,
           loop=FALSE)
```

::: { .f70}
Best projection provided by the guided tour, separating three species.
:::

:::: {.columns}

::: {.column .f70 width=50%}

*Removing flipper length*

![](gifs/p_radial_fl.gif){width=400}
:::

::: {.column .f70 width=50%}

::: {.fragment}
*Removing bill length*

![](gifs/p_radial_bl.gif){width=400}
:::
:::

::::


## Games: Hiding in high-d

::: {.panel-tabset}

## Now you see it

::: {.f70} 
```{r}
#| code-fold: true
#| echo: true
#| label: hiding
library(tidyverse)
library(tourr)
library(GGally)
set.seed(946)
d <- tibble(x1=runif(200, -1, 1), 
            x2=runif(200, -1, 1), 
            x3=runif(200, -1, 1))
d <- d %>%
  mutate(x4 = x3 + runif(200, -0.1, 0.1))
d <- bind_rows(d, c(x1=0, x2=0, x3=-0.5, x4=0.5))

d_r <- d %>%
  mutate(x1 = cos(pi/6)*x1 + sin(pi/6)*x3,
         x3 = -sin(pi/6)*x1 + cos(pi/6)*x3,
         x2 = cos(pi/6)*x2 + sin(pi/6)*x4,
         x4 = -sin(pi/6)*x2 + cos(pi/6)*x4)

```
:::

:::: {.columns}

::: {.column width=50%}

![](images/anomaly1.png)

:::

::: {.column width=50%}

![](gifs/anomaly1.gif){width=500}

:::
::::

## Now you don't

::: {.f70} 

```{r}
#| code-fold: true
#| echo: true
#| eval: false
library(tidyverse)
library(tourr)
library(GGally)
set.seed(946)
d <- tibble(x1=runif(200, -1, 1), 
            x2=runif(200, -1, 1), 
            x3=runif(200, -1, 1))
d <- d %>%
  mutate(x4 = x3 + runif(200, -0.1, 0.1))
d <- bind_rows(d, c(x1=0, x2=0, x3=-0.5, x4=0.5))

d_r <- d %>%
  mutate(x1 = cos(pi/6)*x1 + sin(pi/6)*x3,
         x3 = -sin(pi/6)*x1 + cos(pi/6)*x3,
         x2 = cos(pi/6)*x2 + sin(pi/6)*x4,
         x4 = -sin(pi/6)*x2 + cos(pi/6)*x4)
```
:::

:::: {.columns}

::: {.column width=50%}

![](images/anomaly2.png)

:::

::: {.column width=50%}

![](gifs/anomaly2.gif){width=500}

:::
::::

```{r}
#| eval: false
#| echo: false
# Code to make the plots
ggscatmat(d)
animate_xy(d)
render_gif(d,
           grand_tour(),
           display_xy(
             axes="bottomleft", cex=2.5),
           gif_file = "gifs/anomaly1.gif",
           start = basis_random(4, 2),
           apf = 1/60,
           frames = 1500,
           width = 500, 
           height = 400)
ggscatmat(d_r)
animate_xy(d_r)
render_gif(d_r,
           grand_tour(),
           display_xy(
             axes="bottomleft", cex=2.5),
           gif_file = "gifs/anomaly2.gif",
           start = basis_random(4, 2),
           apf = 1/60,
           frames = 1500,
           width = 500, 
           height = 400)

dsq <- tibble(x1=runif(200, -1, 1), 
            x2=runif(200, -1, 1), 
            x3=runif(200, -1, 1))
dsq <- dsq %>%
  mutate(x4 = x3^2 + runif(200, -0.1, 0.1))
dsq <- bind_rows(dsq, c(x1=0, x2=0, x3=0, x4=1.1))
dsq <- bind_rows(dsq, c(x1=0, x2=0, x3=0.1, x4=1.05))
dsq <- bind_rows(dsq, c(x1=0, x2=0, x3=-0.1, x4=1.0))
ggscatmat(dsq)
animate_xy(dsq, axes="bottomleft")
dsq_r <- dsq %>%
  mutate(x1 = cos(pi/6)*x1 + sin(pi/6)*x3,
         x3 = -sin(pi/6)*x1 + cos(pi/6)*x3,
         x2 = cos(pi/6)*x2 + sin(pi/6)*x4,
         x4 = -sin(pi/6)*x2 + cos(pi/6)*x4)
ggscatmat(dsq_r)
animate_xy(dsq_r, axes="bottomleft")
```

:::

## Philosophy: Model in the data space

:::: {.columns}
::: {.column}

For example, when we teach regression, we overlay the fitted model on the data: MODEL IN THE DATA SPACE.

```{r}
#| fig-width: 6
#| fig-height: 5
library(broom)
mtcars_lm <- lm(mpg~hp, data=mtcars)
mtcars_all <- broom::augment(mtcars_lm)
mtcars_coefs <- tidy(mtcars_lm)
ggplot(mtcars) +
  geom_point(aes(x=hp, y=mpg), size=5) +
  geom_abline(intercept = mtcars_coefs$estimate[1],
              slope = mtcars_coefs$estimate[2],
              colour="#EC5C00", 
              linewidth=3, alpha=0.8)
```

:::
::: {.column}

A residual plot is DATA IN THE MODEL SPACE. When we go beyond 2D, it's considered too hard to show the model in the data space. **It isn't!**

```{r}
#| fig-width: 6
#| fig-height: 5
ggplot(mtcars_all, aes(x=hp, y=.resid)) +
  geom_hline(yintercept = 0) +
  geom_point(size=5) 
```

:::
::::

Wickham et al (2015) https://doi.org/10.1002/sam.11271


## Dimension reduction

::: {.panel-tabset}

## Data in the model space 

:::: {.columns}

::: {.column width=50% .f60}

Principal component analysis

```{r}
#| fig-alt: "Principal component biplot of the penguins data."
p_pca <- prcomp(penguins_sub[,1:4])
p_pca_plt <- autoplot(p_pca, loadings = TRUE, 
         loadings.label = TRUE) +
  theme(aspect.ratio=1,
        panel.grid.major = element_blank())
p_pca_plt
```

:::

::: {.column width=50% .f60}

NLDR: t-Stochastic neighbourhood embedding

```{r}
#| fig-alt: "Dimension reduction with t-SNE on the penguins data shown as a scatterplot."
set.seed(2022)
p_tsne <- Rtsne::Rtsne(penguins_sub[,1:4])
p_tsne_df <- data.frame(tsneX = p_tsne$Y[, 1], tsneY = p_tsne$Y[, 2])
plt_tsne <- ggplot(p_tsne_df, aes(x=tsneX, y=tsneY)) + 
  geom_point() +
  theme(aspect.ratio=1,
        panel.grid.major = element_blank())
plt_tsne
```

:::

::::

## PCA

:::: {.columns}
::: {.column .f60 width=50%}
Data in the model space 


```{r}
#| fig-alt: "Principal component biplot of the penguins data."
p_pca_plt
```

:::

::: {.column .f60 width=50%}

Model in the data space

```{r}
#| eval: false
#| echo: true
#| code-fold: true
library(mulgar)

p_pca_m <- pca_model(p_pca, s=2.2)
p_pca_m_d <- rbind(p_pca_m$points, penguins_sub[,1:4])
p_pca_m_d_clr <- c(rep("#EC5C00", 4), 
                   rep("black", nrow(penguins_sub)))
animate_xy(p_pca_m_d, edges=p_pca_m$edges,
           axes="bottomleft",
           col=p_pca_m_d_clr,
           edges.col="#EC5C00",
           edges.width=3)
render_gif(p_pca_m_d, 
           grand_tour(), 
           display_xy(half_range=4.2,
                      col=p_pca_m_d_clr,
                      edges=p_pca_m$edges, 
                      edges.col="#EC5C00",
                      edges.width=3),
           gif_file="gifs/p_pca_model.gif",
           frames=500,
           width=400,
           height=400,
           loop=FALSE)

```

![](gifs/p_pca_model.gif){width=400}

:::
::::

## tSNE

:::: {.columns}
::: {.column .f70 width=50%}

Data in the model space

```{r}
#| fig-alt: "Dimension reduction with t-SNE on the penguins data shown as a scatterplot."
plt_tsne
```
:::

::: {.column .f70 width=50%}
Model in the data space

::: {style="font-size: 150%"}

```{r}
#| eval: false
p_dat <- penguins_sub[, 1:4] |>
  mutate(ID = 1:n()) |>
  rename(x1 = bl, x2 = bd, x3 = fl, x4 = bm)
p_tsne_df <- p_tsne_df |>
  mutate(ID = 1:n())
p_tsne_m <- fit_highd_model(p_dat,
                            p_tsne_df, 
                            b1=20, q=0.2,
                            benchmark_highdens=0)
p_tsne_tour <- bind_rows(p_tsne_m$model_highd[, 2:5], p_dat[,1:4]) |>
  mutate(type = factor(c(rep("model", nrow(p_tsne_m$model_highd)),
                         rep("data", nrow(p_dat)))))
p_tsne_edges <- as.matrix(p_tsne_m$trimesh_data[,1:2], ncol=2)
p_tsne_p_clr <- c(
  rep("#EC5C00", nrow(p_tsne_m$model_highd)),
  rep("black", nrow(p_dat)))
p_tsne_p_pch <- c(
  rep(3, nrow(p_tsne_m$model_highd)),
  rep(16, nrow(p_dat)))
p_tsne_m_clr <- rep("#EC5C00",
  nrow(p_tsne_m$model_highd))
animate_xy(p_tsne_tour[,1:4], 
           col = p_tsne_p_clr, 
           edges = p_tsne_edges,
           edges.col = p_tsne_m_clr,
           edges.width = 3,
           axes = "bottomleft")
render_gif(p_tsne_tour[,1:4],
           grand_tour(),
           display_xy(half_range=3.5,
             col = p_tsne_p_clr,
             edges = p_tsne_edges,
             edges.col = p_tsne_m_clr,
             edges.width = 3, 
             axes="bottomleft"),
           gif_file = "gifs/p_tsne.gif",
           start = basis_random(4, 2),
           apf = 1/60,
           frames = 500,
           width = 400, 
           height = 400)
```


![](gifs/p_tsne.gif){width=400}


:::

::: {.fragment}
<br><br> <span style="color: #EC5C00;"> https://doi.org/10.48550/arXiv.2506.22051 </span>
:::

:::
::::


## Oddness

:::: {.columns}
::: {.column width=33%}

```{r}
#| fig-height: 4
#| fig-width: 4
#| out-width: 100%
#| fig-alt: "Principal component biplot of the penguins data."
p_pca$x |>
  as_tibble() |>
  mutate(species = penguins_sub$species) |>
  ggplot(aes(x=PC1, y=PC2, colour=species)) +
    geom_point() +
    scale_color_discrete_divergingx(palette="Zissou 1") +
    theme(aspect.ratio=1, 
          legend.position = "none",
          panel.grid.major = element_blank())
```

:::
::: {.column width=33%}

```{r}
#| fig-height: 4
#| fig-width: 4
#| out-width: 100%
p_tsne_df |>
  mutate(species = penguins_sub$species) |>
  ggplot(aes(x=tsneX, y=tsneY, colour=species)) + 
  geom_point() +
  scale_color_discrete_divergingx(palette="Zissou 1") +
  theme(aspect.ratio=1, 
        legend.position = "none",
        panel.grid.major = element_blank())
```
:::

::: {.column width=33%}


```{r}
#| eval: false
p_tsne_p_clr <- c(
  rep("black", nrow(p_tsne_m$model_highd)),
  hcl.colors(3, palette="Zissou 1")[as.numeric(penguins_sub$species)])
render_gif(p_tsne_tour[,1:4],
           grand_tour(),
           display_xy(half_range=3.5,
             col = p_tsne_p_clr,
             edges = p_tsne_edges,
             edges.col = "black",
             edges.width = 3, 
             axes="bottomleft"),
           gif_file = "gifs/p_tsne_coloured.gif",
           start = basis_random(4, 2),
           apf = 1/60,
           frames = 500,
           width = 400, 
           height = 400)
```

![](images/p_tsne_twist.png){width=100%}

:::

::::

:::


## Exploring boundaries

::: {.f70}
The slice tour is especially useful for exploring classification models, **comparing boundaries** produced by different models. (The same penguins data used here.)
:::

::: {.panel-tabset}

## Slice tour

:::: {.columns}

::: {.column .f70 width=50%}

```{r}
#| eval: false
library(MASS)
library(classifly)
p_lda <- lda(species ~ ., penguins_sub[,1:5], prior = c(1/3, 1/3, 1/3))
p_lda_boundaries <- explore(p_lda, penguins_sub)
set.seed(1209)
gt2 <- save_history(penguins_sub[,1:4], 
                    tour_path = grand_tour(), 
                    max_bases=200)
animate_slice(p_lda_boundaries[
  p_lda_boundaries$.BOUNDARY == TRUE, 1:4], 
              col=p_lda_boundaries$species[
                p_lda_boundaries$.BOUNDARY == TRUE], 
              v_rel=0.8, 
              axes="bottomleft")
render_gif(
  p_lda_boundaries[
    p_lda_boundaries$.BOUNDARY == TRUE, 1:4],
           planned_tour(gt2),
           display_slice(v_rel=0.8, 
             col=p_lda_boundaries$species[
               p_lda_boundaries$.BOUNDARY == TRUE], 
             axes="bottomleft"),     
           gif_file="gifs/penguins_lda_boundaries.gif",
           frames=500,
           loop=FALSE
  )
```

Linear discriminant analysis

![](gifs/penguins_lda_boundaries.gif){width=400}
:::

::: {.column .f70 width=50%}

```{r}
#| eval: false
library(rpart)
p_tree <- rpart(species~., 
                data=penguins_sub[,1:5])
p_tree_boundaries <- explore(p_tree, penguins_sub)
animate_slice(p_tree_boundaries[
  p_tree_boundaries$.BOUNDARY == TRUE, 1:4], 
              col=p_tree_boundaries$species[
                p_tree_boundaries$.BOUNDARY == TRUE], 
              v_rel=0.8, 
              axes="bottomleft")
render_gif(
  p_tree_boundaries[
    p_tree_boundaries$.BOUNDARY == TRUE, 1:4],
           planned_tour(gt2),
           display_slice(v_rel=0.8, 
             col=p_tree_boundaries$species[
               p_tree_boundaries$.BOUNDARY == TRUE], 
             axes="bottomleft"),     
           gif_file="gifs/penguins_tree_boundaries.gif",
           frames=500,
           loop=FALSE
  )
```

Classification tree

![](gifs/penguins_tree_boundaries.gif){width=400}
:::

::::

## Static plots

:::: {.columns}

::: {.column .f70 width=50%}

Linear discriminant analysis

![](images/p_lda_bndry.png)

:::
::: {.column .f70 width=50%}

Classification tree

![](images/p_tree_bndry.png)

:::

::::

:::

## Understanding clustering [(1/2)]{.f50}

::: {.panel-tabset}


## Model-based

```{r}
#| fig-width: 6
#| out-width: 60%
#| fig-alt: "BIC values for a range of models and number of clusters."
penguins_BIC <- mclustBIC(penguins_sub[,1:4])
ggmc <- ggmcbic(penguins_BIC, cl=2:9, top=7) + 
  scale_color_discrete_divergingx(palette = "Roma") +
  theme_minimal() 
ggmc
```

## Which is best?

:::: {.columns}

::: {.column width=50%}
Best model: four-cluster VEE

![](gifs/penguins_best_mc.gif){fig-alt="Tour showing best cluster model according to model-based clustering."}

:::

::: {.column width=50% .fragment}
Three-cluster EEE

![](gifs/penguins_simpler_mc.gif){fig-alt="Tour showing best three cluster model, which fits better than the best model."}

:::

::::

:::

## Understanding clustering [(2/2)]{.f50}

```{r}
#| eval: true
p_dist <- dist(penguins_sub[,1:4])
p_hcw <- hclust(p_dist, method="ward.D2")

p_cl <- data.frame(cl_w = cutree(p_hcw, 3))

penguins_mc <- Mclust(penguins_sub[,1:4], 
                      G=3, 
                      modelNames = "EEE")
p_cl <- p_cl |>
  mutate(cl_mc = penguins_mc$classification)

p_cl <- p_cl |>
  mutate(cl_w_j = jitter(cl_w),
         cl_mc_j = jitter(cl_mc))
```

:::: {.columns}

::: {.column width=50%}

Interactivity: Compare cluster models 

```{r}
#| eval: false
library(gt)
p_cl |>
  count(cl_w, cl_mc) |>
  pivot_wider(names_from = cl_mc, 
              values_from = n, 
              values_fill = 0) %>%
  gt() %>%
  tab_spanner(label = "cl_mc", columns=c(`1`, `2`, `3`)) %>%
  cols_width(everything() ~ px(60))
penguins_cl <- penguins_sub %>%
  mutate(cl_w_j = p_cl$cl_w_j,
         cl_mc_j = p_cl$cl_mc_j) %>%
  mutate(cl_w = factor(p_cl$cl_w),
         cl_mc = factor(p_cl$cl_mc)) 
```

DEMO

::: {.f60}
DATA 1: projections

\begin{eqnarray*}
Y_{~n\times d} = XA = \left[ \begin{array}{cccc}
y_{~11} & y_{~12} & \dots & y_{~1d} \\
y_{~21} & y_{~22} & \dots & y_{~2d}\\
\vdots & \vdots &  & \vdots \\
y_{~n1} & y_{~n2} & \dots & y_{~nd} \end{array} \right]_{~n\times d}
\end{eqnarray*}

DATA 2: cluster labels

\begin{eqnarray*}
C = \left[ \begin{array}{cc}
c_{~11} & c_{~12}  \\
c_{~21} & c_{~22} \\
\vdots & \vdots  \\
c_{~n1} & c_{~n2} \end{array} \right]_{~n\times 2}
\end{eqnarray*}

:::

:::

::: {.column width=50%}

```{r}
#| eval: false
#| echo: false
limn_tour_link(
  penguins_cl[,7:8],
  penguins_cl,
  cols = bl:bm,
  color = cl_w
)
```

```{r}
#| eval: false
#| echo: true
library(crosstalk)
library(plotly)
library(viridis)
p_cl_shared <- SharedData$new(penguins_cl)

detour_plot <- detour(p_cl_shared, tour_aes(
  projection = bl:bm,
  colour = cl_w)) |>
    tour_path(grand_tour(2), 
                    max_bases=50, fps = 60) |>
       show_scatter(alpha = 0.7, axes = FALSE,
                    width = "100%", height = "450px")

conf_mat <- plot_ly(p_cl_shared, 
                    x = ~cl_mc_j,
                    y = ~cl_w_j,
                    color = ~cl_w,
                    colors = viridis_pal(option = "D")(3),
                    height = 450) |>
  highlight(on = "plotly_selected", 
              off = "plotly_doubleclick") %>%
    add_trace(type = "scatter", 
              mode = "markers")
  
bscols(
     detour_plot, conf_mat,
     widths = c(5, 6)
 )                 
```

:::

::::

## Departures from normal

::: {.panel-tabset}

## Normal?

:::: {.columns}
::: {.column}

![](gifs/women.gif) 

:::
::: {.column}

Liver function (6D) among a sample of patients (all women). 

:::
::::

## Longitudinal

:::: {.columns}
::: {.column}

![](gifs/w_long.gif) 

:::
::: {.column}

Liver function (6D) among a sample of aging patients patients. 

:::
::::

```{r}
#| eval: false
#| message: false
#| warning: false
# Not used now, this is the hypothesis testing example
library(readxl)
library(tidyverse)
library(tourr)
d <- read_xlsx("data/HarveySherrattDungBeetleMorphometricData.xlsx")
d <- d[-1,]
d_sub <- d |>
  select(Distribution, Strategy, `Head Width`, `Head Length`, `Head Height`) |>
  mutate(`Head Width` = as.numeric(if_else(str_detect(`Head Width`, "X"), "", `Head Width`)), 
         `Head Length` = as.numeric(if_else(str_detect(`Head Length`, "X"), "", `Head Length`)), 
         `Head Height` = as.numeric(if_else(str_detect(`Head Height`, "X"), "", `Head Height`))) |>
  na.omit() |>
  mutate(Distribution = factor(Distribution),
         Strategy = factor(Strategy),
         DS = factor(paste0(Distribution, Strategy)))

animate_xy(d_sub[,3:5], col=d_sub$Distribution)
animate_xy(d_sub[,3:5], col=d_sub$DS)

d_miss <- d |>
  mutate_all(~str_replace(., "X", "")) |>
  mutate(across(contains("Width"), as.numeric)) |>
  mutate(across(contains("Length"), as.numeric)) |>
  mutate(across(contains("Height"), as.numeric)) 

library(naniar)
vis_miss(d_impute[,9:35])

d_impute <- d_miss |>
  impute_mean_if(is.numeric)

animate_xy(d_impute[,c(9, 10, 12,13)], col=d$Distribution, rescale=TRUE)

d_pca <- prcomp(d_impute[,c(9, 10, 12, 13, 15, 16)], scale=TRUE)
d_pcx <- d_pca$x |>
  as_tibble() |>
  mutate_all(function(x) (x-mean(x))/sd(x)) |>
  mutate(Distribution = factor(d_impute$Distribution))

animate_xy(d_pcx[,1:6], col=d_pcx$Distribution)
animate_xy(d_pcx[,1:6], guided_tour(lda_pp(d_pcx$Distribution)),
           col=d_pcx$Distribution)

d_pcx_native <- d_pcx |>
  filter(Distribution == "Native")
animate_xy(d_pcx[,1:4], 
           ellipse = diag(1, 4, 4), 
           ellc = 20,
           axes = "bottomleft")

```

:::

See [Calvi, Laa, Cook (2025)](https://doi.org/10.1080/10618600.2025.2468785)

## Deconstructing neural networks

::: {.panel-tabset}

## Data

:::: {.columns}
::: {.column width=50%}

![](https://tensorflow.rstudio.com/tutorials/keras/img/fashion-mnist-sprite.png){width=80%}


:::

::: {.column width=50%}

::: {.f80}

Example: MNIST fashion

10 fashion items, 60000 training 28x28 images

Model fitted as described in [keras tutorial](https://tensorflow.rstudio.com/tutorials/keras/classification).

Single hidden layer with 128 nodes, which reduces the 28x28=<span style="color:#EC5C00"> 784-dimensional</span> space to <span style="color:#EC5C00"> 128-dimensional</span> space. 

*What does this dimension reduction do for the classification?*

Principal components is the usual way to manage constructing a smaller number of dimensions to view the data. 

:::
:::

::::

## NN Model

![](images/nn-diagram.png){width=40%}

Feedforward back-propagation model

## Two PCs

![](images/fashion-PC1-2.png){width=80%}

## Five PCs

:::: {.columns}
::: {.column width=50%}

Input space

![](gifs/fashion_images_gt.gif){width=70%}

:::
::: {.column width=50%}

Activations

![](gifs/fashion_activations_gt.gif){width=70%}


:::

::::


:::

## High-dimensional ternary diagrams

::: {.f70}
If you have more than three components in a compositional data set, the data falls inside a simplex, of more than 2D.
:::

::: {.panel-tabset}

## 2D

:::: {.columns}
::: {.column}

![](gifs/penguins_rf_votes.gif){width=60%}


:::
::: {.column}

![](images/p-votes-ggplot-1.png){width=70%}

:::
::::

## High-d

:::: {.columns}
::: {.column width=40%}

![](gifs/bushfires_votes.gif){width=80%}
:::

::: {.column width=60%}

::: {.f80}
Each component forms one vertex of the simplex. Points 

- at vertices are certain predictions
- far from their vertex are uncertain, likely confused
- along an edge are confused between two groups only
- along a face are confused between three groups

Helps to understand uncertainty in predictions more than is possible with a confusion matrix. 
:::

:::
::::

:::

## Summary

::: {.f90}
The [tourr](http://ggobi.github.io/tourr/) package provides the algorithm to generate the tour paths of projection bases, and also the ability to create new tours, and draw projections with a variety of different display methods. 
:::

:::: {.columns}
::: {.column width=50%}

<br><br><br>
Tours provide the ability to do statistics with visual help. 




:::

::: {.column width=50% .fragment}

::: {.f80}
<br>

These paths of projections can be generated off-line and used with other software.

Elegant interactivity solutions with [detourr](https://casperhart.github.io/detourr/), [liminal](https://sa-lee.github.io/liminal/), [langevitour](https://logarithmic.net/langevitour/index.html), [lionfish](https://mmedl.github.io/lionfish) but need to be developed further.
:::

:::

::::


## High-d vis intellectually challenging, and fun! {.center}

*Please use these tools* ðŸ˜ƒ

## References and acknowledgements

::: {style="font-size: 90%;"}

- Cook and Laa (2023) [Interactively exploring high-dimensional data and models in R](https://dicook.github.io/mulgar_book/)
- Wickham et al (2015) [Visualizing statistical models: Removing the blindfold](https://doi.org/10.1002/sam.11271)
- [Flatland: A Romance of Many Dimensions (1884) Edwin Abbott](https://en.wikipedia.org/wiki/Flatland)
- R packages: [tourr](http://ggobi.github.io/tourr/), [woylier](https://numbats.github.io/woylier/), [detourr](https://casperhart.github.io/detourr/), [liminal](https://sa-lee.github.io/liminal/), [langevitour](https://logarithmic.net/langevitour/index.html), [lionfish](https://mmedl.github.io/lionfish), [geozoo](http://schloerke.com/geozoo/all/).

Slides made in [Quarto](https://quarto.org/), with code included.  

<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
:::

